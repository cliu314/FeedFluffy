all da commented out things



//Create a hungry eevee and add it to layer
        /*CCSprite *hungryEevee = [CCSprite spriteWithFile: @"hungryEevee.png"];
        hungryEevee.position = ccp(winSize.width - 10, winSize.height/2);
        [self addChild:hungryEevee z:0 tag:2];
        
        //Create the hungry eevee mouth -- useful to detect collision
        
        CCSprite *hungryEeveeMouth = [CCSprite spriteWithFile: @"hungryEeveeMouth.png"];
        hungryEeveeMouth.position = ccp(450, 148);
        [self addChild:hungryEeveeMouth z:-1 tag:1];*/




//        // Create paddle body
//        b2BodyDef paddleBodyDef;
//        paddleBodyDef.type = b2_dynamicBody;
//        //paddleBodyDef.position.Set(winSize.width/2/PTM_RATIO, winSize.height/2/PTM_RATIO);
//        paddleBodyDef.position.Set(10/PTM_RATIO, winSize.height/2/PTM_RATIO);
//        paddleBodyDef.userData = (__bridge void*)paddle;
//        _paddleBody = world->CreateBody(&paddleBodyDef);
//
        
        // Create paddle shape
//        b2PolygonShape paddleShape;
//        paddleShape.SetAsBox(_player.contentSize.width/PTM_RATIO/2,
//                             _player.contentSize.height/PTM_RATIO/2);
//        
//        // Create shape definition and add to body
//        b2FixtureDef paddleShapeDef;
//        paddleShapeDef.shape = &paddleShape;
//        paddleShapeDef.density = 10.0f;
//        paddleShapeDef.friction = 0.4f;
//        paddleShapeDef.restitution = 0.1f;
//        _paddleFixture = _paddleBody->CreateFixture(&paddleShapeDef);


        //Make paddle horizontal plane


//        b2PrismaticJointDef jointDef;
//        b2Vec2 worldAxis(0.0f, 1.0f);
//        jointDef.collideConnected = true;
//        jointDef.Initialize(_paddleBody, _groundBody, _paddleBody->GetWorldCenter(), worldAxis);
//
//        world->CreateJoint(&jointDef);





//- ( void ) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    UITouch *touch = [touches anyObject];
//    locationTouchBegan = [touch locationInView: [touch view]];
//    //location is The Point Where The User Touched
//    locationTouchBegan = [[CCDirector sharedDirector] convertToGL:locationTouchBegan];
//    //Detect the Touch On Ball
//    if(CGRectContainsPoint([ball boundingBox], locationTouchBegan))
//    {
//        isBallTouched=YES;
//    }
//
//}
//- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    // Choose one of the touches to work with
//    UITouch *touch = [touches anyObject];
//    CGPoint location = [touch locationInView:[touch view]];
//    location = [[CCDirector sharedDirector] convertToGL:location];
//
//    //  Determine offset of location to projectile
//    int offX = location.x - ball.position.x;
//    int offY = location.y - ball.position.y;
//
//    // Bail out if we are shooting down or backwards
//    if (offX <= 0)
//        return;
//
//    // Determine where we wish to shoot the projectile to
//    int realX = winSize.width + (ball.contentSize.height/2);
//    float ratio = (float) offY / (float) offX;
//    int realY = (realX * ratio) + ball.position.y;
//    CGPoint realDest = ccp(realX, realY);
//
//    if(realX>=320)
//        realX = 320;
//    if(realY>=480)
//        realY = 480;
//
//
//    //int good = goodBarrel.position.x;
//    //int bad = badBarrel.position.x;
//
//    int destY = realDest.x;
//
//    realDest.x = destY+10;
//
//    // Determine the length of how far we're shooting
//    int offRealX = realX - ball.position.x;
//    int offRealY = realY - ball.position.y;
//    float length = sqrtf((offRealX*offRealX)+(offRealY*offRealY));
//    float velocity = 480/1; // 480pixels/1sec
//    float realMoveDuration = length/velocity;
//
//    // Move projectile to actual endpoint
//    [ball runAction:[CCSequence actions:
//                     [CCMoveTo actionWithDuration:realMoveDuration position:realDest],
//                     [CCCallFuncN actionWithTarget:self selector:@selector(spriteMoveFinished:)],
//                     nil]];
//    [ball runAction:[CCScaleTo actionWithDuration:realMoveDuration scale:0.4f]];
//	if ((self = [super init]))
//	{
//		CCLOG(@"%@ init", NSStringFromClass([self class]));
//
//		glClearColor(0.1f, 0.0f, 0.2f, 1.0f);
//
//		// Construct a world object, which will hold and simulate the rigid bodies.
//		b2Vec2 gravity = b2Vec2(0.0f, -10.0f);
//		world = new b2World(gravity);
//		world->SetAllowSleeping(YES);
//		//world->SetContinuousPhysics(YES);
//
//		// uncomment this line to draw debug info
//		[self enableBox2dDebugDrawing];
//
//		contactListener = new ContactListener();
//		world->SetContactListener(contactListener);
//
//		// for the screenBorder body we'll need these values
//		CGSize screenSize = [CCDirector sharedDirector].winSize;
//		float widthInMeters = screenSize.width / PTM_RATIO;
//		float heightInMeters = screenSize.height / PTM_RATIO;
//		b2Vec2 lowerLeftCorner = b2Vec2(0, 0);
//		b2Vec2 lowerRightCorner = b2Vec2(widthInMeters, 0);
//		b2Vec2 upperLeftCorner = b2Vec2(0, heightInMeters);
//		b2Vec2 upperRightCorner = b2Vec2(widthInMeters, heightInMeters);
//
//		// Define the static container body, which will provide the collisions at screen borders.
//		b2BodyDef screenBorderDef;
//		screenBorderDef.position.Set(0, 0);
//		b2Body* screenBorderBody = world->CreateBody(&screenBorderDef);
//		b2EdgeShape screenBorderShape;
//
//		// Create fixtures for the four borders (the border shape is re-used)
//		screenBorderShape.Set(lowerLeftCorner, lowerRightCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(lowerRightCorner, upperRightCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(upperRightCorner, upperLeftCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(upperLeftCorner, lowerLeftCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//
//		NSString* message = @"Tap Screen For More Awesome!";
//		if ([CCDirector sharedDirector].currentPlatformIsMac)
//		{
//			message = @"Click Window For More Awesome!";
//		}
//
//		CCLabelTTF* label = [CCLabelTTF labelWithString:message fontName:@"Marker Felt" fontSize:32];
//		[self addChild:label];
//		[label setColor:ccc3(222, 222, 255)];
//		label.position = CGPointMake(screenSize.width / 2, screenSize.height - 50);
//
//		// Use the orthogonal tileset for the little boxes
//		CCSpriteBatchNode* batch = [CCSpriteBatchNode batchNodeWithFile:@"dg_grounds32.png" capacity:TILESET_ROWS * TILESET_COLUMNS];
//		[self addChild:batch z:0 tag:kTagBatchNode];
//
//		// Add a few objects initially
//		for (int i = 0; i < 9; i++)
//		{
//			[self addNewSpriteAt:CGPointMake(screenSize.width / 2, screenSize.height / 2)];
//		}
//
//		[self addSomeJoinedBodies:CGPointMake(screenSize.width / 4, screenSize.height - 50)];
//
//		[self scheduleUpdate];
//
//		[KKInput sharedInput].accelerometerActive = YES;
//	}
//
//	return self;
