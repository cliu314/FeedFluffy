all da commented out things



        //This code is not needed anymore - I believe.
        
        //if (CGRectContainsPoint(leftBorder, location)) {
        if (counter==3 ) {
            
//            NSLog(@"SDFJDS:FJSDKFJ");
//            
//            // Set up initial location of projectile
//            winSize = [[CCDirector sharedDirector] winSize];
//            _nextProjectile = [CCSprite spriteWithFile:@"bullet.png"];
//            _nextProjectile.tag = 1;
//            
//            _nextProjectile.position = _player.position;
//            [balls addObject: _nextProjectile];
//            
//            // Create ball body and shape
//            
//            ballBodyDef.type = b2_dynamicBody;
//            //            ballBodyDef.position.Set(100/PTM_RATIO, 100/PTM_RATIO);
//            NSLog(@"SHOULD NOT BE IN HERE!(*&^(*&^(*&^(&^");
//            ballBodyDef.position.Set(_player.position.x/PTM_RATIO,_player.position.y/PTM_RATIO);
//            ballBodyDef.userData = (__bridge void*)_nextProjectile;
//            
//            _body = world->CreateBody(&ballBodyDef);
//            
//            b2CircleShape circle;
//            //circle.m_radius = 26.0/PTM_RATIO;
//            //circle.m_radius = 9.0/PTM_RATIO;
//            circle.m_radius = 20.0/PTM_RATIO;
//            
//            b2FixtureDef ballShapeDef;
//            ballShapeDef.shape = &circle;
//            ballShapeDef.density = 0.5f;
//            ballShapeDef.friction = 0.0f;
//            ballShapeDef.restitution = 1.0f;
//            _body->CreateFixture(&ballShapeDef);
//            
//            
//            
//            // Determine offset of location to projectile
//            CGPoint offset = ccpSub(location, _nextProjectile.position);
//            // Bail out if you are shooting down or backwards
//            if (offset.x <= 0) return;
//            
//            // Determine where you wish to shoot the projectile to
//            int realX = winSize.width + (_nextProjectile.contentSize.width/2);
//            float ratio = (float) offset.y / (float) offset.x;
//            int realY = (realX * ratio) + _nextProjectile.position.y;
//            realDest = ccp(realX, realY);
//            
//            // Determine the length of how far you're shooting
//            int offRealX = realX - _nextProjectile.position.x;
//            int offRealY = realY - _nextProjectile.position.y;
//            float length = sqrtf((offRealX*offRealX)+(offRealY*offRealY));
//            float velocity = 480/1; // 480pixels/1sec
//            realMoveDuration = length/velocity;
//            // Determine angle to face
//            angleRadians = atanf((float)offRealY / (float)offRealX);
//            float angleDegrees = CC_RADIANS_TO_DEGREES(angleRadians);
//            float cocosAngle = -1 * angleDegrees;
//            float rotateDegreesPerSecond = 180 / 0.5; // Would take 0.5 seconds to rotate 180 degrees, or half a circle
//            //_player.anchorPoint = ccp(0.5, 0.5);
//            
//            float degreesDiff = _player.rotation - cocosAngle;
//            float rotateDuration = fabs(degreesDiff / rotateDegreesPerSecond);
//            
//            [_player runAction:[CCSequence actions:[CCRotateTo actionWithDuration:rotateDuration angle:cocosAngle],nil]];
            
            
            //            if (ButtonTapped) {
            //             [_player runAction:[CCSequence actions:[CCCallBlock actionWithBlock:^{[self addChild:_nextProjectile];_nextProjectile = nil;}],nil]];
            //            //this determines the speed of the ball projectile
            //            b2Vec2 force = b2Vec2(cos(angleRadians), sin(angleRadians));
            //
            //            //_body->ApplyLinearImpulse(force, ballBodyDef.position);
            //            printf("Applying Linear Impulse!");
            //            _body->ApplyLinearImpulse(force, ballBodyDef.position);
            //
            //            // Move projectile to actual endpoint
            //            [_nextProjectile runAction:
            //             [CCSequence actions:
            //              [CCMoveTo actionWithDuration:realMoveDuration position:realDest],
            //              [CCCallBlockN actionWithBlock:^(CCNode *node) {
            //                 [node removeFromParentAndCleanup:YES];
            //             }],
            //              nil]];
            //            bulletCounter--;
            //                ButtonTapped = false;
            //            _player.tag = 4;
            //            }
            
        }
        else{
            
            printf("Not in Range - Don't SHOOT!!!!!!!!!!!!!\n");
            
        }




//            NSLog(@"SDFJDS:FJSDKFJ");
//            
//            // Set up initial location of projectile
//            winSize = [[CCDirector sharedDirector] winSize];
//            _nextProjectile = [CCSprite spriteWithFile:@"bullet.png"];
//            _nextProjectile.tag = 1;
//            
//            _nextProjectile.position = _player.position;
//            [balls addObject: _nextProjectile];
//            
//            // Create ball body and shape
//            
//            ballBodyDef.type = b2_dynamicBody;
//            //            ballBodyDef.position.Set(100/PTM_RATIO, 100/PTM_RATIO);
//            NSLog(@"SHOULD NOT BE IN HERE!(*&^(*&^(*&^(&^");
//            ballBodyDef.position.Set(_player.position.x/PTM_RATIO,_player.position.y/PTM_RATIO);
//            ballBodyDef.userData = (__bridge void*)_nextProjectile;
//            
//            _body = world->CreateBody(&ballBodyDef);
//            
//            b2CircleShape circle;
//            //circle.m_radius = 26.0/PTM_RATIO;
//            //circle.m_radius = 9.0/PTM_RATIO;
//            circle.m_radius = 20.0/PTM_RATIO;
//            
//            b2FixtureDef ballShapeDef;
//            ballShapeDef.shape = &circle;
//            ballShapeDef.density = 0.5f;
//            ballShapeDef.friction = 0.0f;
//            ballShapeDef.restitution = 1.0f;
//            _body->CreateFixture(&ballShapeDef);
//            
//            
//            
//            // Determine offset of location to projectile
//            CGPoint offset = ccpSub(location, _nextProjectile.position);
//            // Bail out if you are shooting down or backwards
//            if (offset.x <= 0) return;
//            
//            // Determine where you wish to shoot the projectile to
//            int realX = winSize.width + (_nextProjectile.contentSize.width/2);
//            float ratio = (float) offset.y / (float) offset.x;
//            int realY = (realX * ratio) + _nextProjectile.position.y;
//            realDest = ccp(realX, realY);
//            
//            // Determine the length of how far you're shooting
//            int offRealX = realX - _nextProjectile.position.x;
//            int offRealY = realY - _nextProjectile.position.y;
//            float length = sqrtf((offRealX*offRealX)+(offRealY*offRealY));
//            float velocity = 480/1; // 480pixels/1sec
//            realMoveDuration = length/velocity;
//            // Determine angle to face
//            angleRadians = atanf((float)offRealY / (float)offRealX);
//            float angleDegrees = CC_RADIANS_TO_DEGREES(angleRadians);
//            float cocosAngle = -1 * angleDegrees;
//            float rotateDegreesPerSecond = 180 / 0.5; // Would take 0.5 seconds to rotate 180 degrees, or half a circle
//            //_player.anchorPoint = ccp(0.5, 0.5);
//            
//            float degreesDiff = _player.rotation - cocosAngle;
//            float rotateDuration = fabs(degreesDiff / rotateDegreesPerSecond);
//            
//            [_player runAction:[CCSequence actions:[CCRotateTo actionWithDuration:rotateDuration angle:cocosAngle],nil]];
            
            
            //            if (ButtonTapped) {
            //             [_player runAction:[CCSequence actions:[CCCallBlock actionWithBlock:^{[self addChild:_nextProjectile];_nextProjectile = nil;}],nil]];
            //            //this determines the speed of the ball projectile
            //            b2Vec2 force = b2Vec2(cos(angleRadians), sin(angleRadians));
            //
            //            //_body->ApplyLinearImpulse(force, ballBodyDef.position);
            //            printf("Applying Linear Impulse!");
            //            _body->ApplyLinearImpulse(force, ballBodyDef.position);
            //
            //            // Move projectile to actual endpoint
            //            [_nextProjectile runAction:
            //             [CCSequence actions:
            //              [CCMoveTo actionWithDuration:realMoveDuration position:realDest],
            //              [CCCallBlockN actionWithBlock:^(CCNode *node) {
            //                 [node removeFromParentAndCleanup:YES];
            //             }],
            //              nil]];
            //            bulletCounter--;
            //                ButtonTapped = false;
            //            _player.tag = 4;
            //            }








//        _nextProjectile = [CCSprite spriteWithFile:@"bullet.png"];
//        _nextProjectile.tag = 1;
//        
//        _nextProjectile.position = _player.position;
//        [balls addObject: _nextProjectile];
//        // Create ball body and shape
//        
//        ballBodyDef.type = b2_dynamicBody;
//        //            ballBodyDef.position.Set(100/PTM_RATIO, 100/PTM_RATIO);
//        NSLog(@"in Position.SET\n");
//        ballBodyDef.position.Set(_player.position.x/PTM_RATIO,_player.position.y/PTM_RATIO);
//        ballBodyDef.userData = (__bridge void*)_nextProjectile;
//        
//        _body = world->CreateBody(&ballBodyDef);
//        
//        b2CircleShape circle;
//        //circle.m_radius = 26.0/PTM_RATIO;
//        //circle.m_radius = 9.0/PTM_RATIO;
//        circle.m_radius = 20.0/PTM_RATIO;
//        
//        b2FixtureDef ballShapeDef;
//        ballShapeDef.shape = &circle;
//        ballShapeDef.density = 0.5f;
//        ballShapeDef.friction = 0.0f;
//        ballShapeDef.restitution = 1.0f;
//        _body->CreateFixture(&ballShapeDef);







        //I don't think we need this anymore
        //        movableSprites = [[NSMutableArray alloc] init];
        //        NSArray *images = [NSArray arrayWithObjects:@"hungryEevee.png", @"hungryEeveeMouth.png", @"dog.png", @"turtle.png", nil];



~~~~~~~~~~~~~~~~~

//- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
//{
//
//    UITouch *touch = [touches anyObject];
//    CGPoint poBefore = [touch locationInView:[touch view]];
//    poBefore = [[CCDirector sharedDirector] convertToGL:poBefore];
//    
    //    // Fail when more than 1 finger detected.
    

//    
//    
//    if (CGRectContainsPoint(_player.boundingBox, poBefore))
//    {
//        _MoveableSpriteTouch = true;
//    }
//}

CGFloat arrowRotation = 180;
//- (void)ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    
//    UITouch *touch = [touches anyObject];
////
////    
////    CGPoint point = [touch locationInView:[touch view]];
////    
////    point = [[CCDirector sharedDirector] convertToGL:point];
////
////    if(_MoveableSpriteTouch==TRUE){
////        
////        [_player setPosition:point];
////        
////    }
//    
//    //acquire the previous touch location
//    
//    CGPoint firstLocation = [touch previousLocationInView:[touch view]];
//    CGPoint location = [touch locationInView:[touch view]];
//    
//    //preform all the same basic rig on both the current touch and previous touch
//    CGPoint touchingPoint = [[CCDirector sharedDirector] convertToGL:location];
//    CGPoint firstTouchingPoint = [[CCDirector sharedDirector] convertToGL:firstLocation];
//    
//    CGPoint firstVector = ccpSub(firstTouchingPoint, _player.position);
//    CGFloat firstRotateAngle = -ccpToAngle(firstVector);
//    CGFloat previousTouch = CC_RADIANS_TO_DEGREES(firstRotateAngle);
//    
//    CGPoint vector = ccpSub(touchingPoint, _player.position);
//    CGFloat rotateAngle = -ccpToAngle(vector);
//    CGFloat currentTouch = CC_RADIANS_TO_DEGREES(rotateAngle);
//    
//    printf("ccTouchesMoved");
//    
//    //keep adding the difference of the two angles to the dial rotation
//    arrowRotation += currentTouch - previousTouch;
//    if (arrowRotation >= 50) {
//        printf("ARROW.........\n");
//        arrowRotation = 50;
//    }
//    
//    else if (arrowRotation <= 20) {
//        printf("ARROW.........\n");
//        arrowRotation = 20;
//    }

//    //UITouch *touch = [touches anyObject];
//
//    CGPoint touchLocation = [self convertTouchToNodeSpace:touch];
//    
//    CGPoint oldTouchLocation = [touch previousLocationInView:touch.view];
//    oldTouchLocation = [[CCDirector sharedDirector] convertToGL:oldTouchLocation];
//    oldTouchLocation = [self convertToNodeSpace:oldTouchLocation];
//    
//    CGPoint translation = ccpSub(touchLocation, oldTouchLocation);
//    CGPoint newPos = ccpAdd(_player.position, translation);
//    //_player.position = newPos;
//    _player.position = ccp(_player.position.x, newPos.y);

//}


- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {
    printf("CCTouchesEnded!\n");
//    //Checking if 3 bullets have already been used - if so, then no more bullet are thrown.
//    if (_nextProjectile != nil or bulletCounter<=0) return;
//
//    _MoveableSpriteTouch=FALSE;
//    
//    // Choose one of the touches to work with
//    UITouch *touch = [touches anyObject];
//    CGPoint location = [self convertTouchToNodeSpace:touch];
//    CGRect leftBorder = CGRectMake(cageLeft, 0, cageLeft+10, 350);
//   
//    
//    if (CGRectContainsPoint(leftBorder, location)) {
//        printf("Correctly within border - in ccTouchesEnded");
//    // Set up initial location of projectile
//    CGSize winSize = [[CCDirector sharedDirector] winSize];
//    _nextProjectile = [CCSprite spriteWithFile:@"projectile2.png"];
//    //_nextProjectile.position = ccp(20, winSize.height/2);
//    //_nextProjectile.position = _player.position;
//    _nextProjectile.position = ccp(_player.position.x, _player.position.y+12.5); //so that ball exits out of cannon arm and not center of wheel
//    [balls addObject: _nextProjectile];
//    
//    // Determine offset of location to projectile
//    CGPoint offset = ccpSub(location, _nextProjectile.position);
//    // Bail out if you are shooting down or backwards
//    if (offset.x <= 0) return;
// 
//    // Determine where you wish to shoot the projectile to
//    int realX = winSize.width + (_nextProjectile.contentSize.width/2);
//    float ratio = (float) offset.y / (float) offset.x;
//    int realY = (realX * ratio) + _nextProjectile.position.y;
//    CGPoint realDest = ccp(realX, realY);
//    
//    // Determine the length of how far you're shooting
//    int offRealX = realX - _nextProjectile.position.x;
//    int offRealY = realY - _nextProjectile.position.y;
//    float length = sqrtf((offRealX*offRealX)+(offRealY*offRealY));
//    float velocity = 480/1; // 480pixels/1sec
//    float realMoveDuration = length/velocity;
//    // Determine angle to face
//    float angleRadians = atanf((float)offRealY / (float)offRealX);
//    float angleDegrees = CC_RADIANS_TO_DEGREES(angleRadians);
//    float cocosAngle = -1 * angleDegrees;
//    float rotateDegreesPerSecond = 180 / 0.5; // Would take 0.5 seconds to rotate 180 degrees, or half a circle
//    //_player.anchorPoint = ccp(0.5, 0.5);
//    
//    float degreesDiff = _player.rotation - cocosAngle;
//    float rotateDuration = fabs(degreesDiff / rotateDegreesPerSecond);
//         
//        [_player runAction:
//         [CCSequence actions:
//          [CCRotateTo actionWithDuration:rotateDuration angle:cocosAngle],
//          [CCCallBlock actionWithBlock:^{
//             // OK to add now - rotation is finished!
//             [self addChild:_nextProjectile];
//             // Release
//             _nextProjectile = nil;
//         }],
//          nil]];
//    // Move projectile to actual endpoint
//    [_nextProjectile runAction:
//     [CCSequence actions:
//      [CCMoveTo actionWithDuration:realMoveDuration position:realDest],
//      [CCCallBlockN actionWithBlock:^(CCNode *node) {
//         [node removeFromParentAndCleanup:YES];
//     }],
//      nil]];
//        bulletCounter--;
//        
//    _player.tag = 4;
//    
//}
//    else{
//    
//        printf("FAILURE!!!!!!!!!!!!!\n");
//    
//    }
    }



//add this back after I find where the projectile went
 
//    //check if the ball hit the target
//    CCSprite *mouth = [self getChildByTag:1];
//    
//    //check if their x coordinates are close enough
//    if(ball.position.x < (mouth.position.x + 10.0f) && ball.position.y < (mouth.position.x - 10.0f))
//    {
//        //check if their y coordinates are close enough
//        if(ball.position.y < (mouth.position.y + 10.0f) && ball.position.y > mouth.position.y - 10.0f)
//        {
//            [self removeChild:ball cleanup: YES];
//            //[[CCDirector sharedDirector] replaceScene: (CCScene*)[[GameLayer alloc] init]];
//        }
//    }

//}



        // Create ball body and shape
        /*b2BodyDef ballBodyDef;
        ballBodyDef.type = b2_dynamicBody;
        ballBodyDef.position.Set(100/PTM_RATIO, 100/PTM_RATIO);
        ballBodyDef.userData = (__bridge void*)_nextProjectile;
        
        b2Body *_body = world->CreateBody(&ballBodyDef);
        
        b2CircleShape circle;
        circle.m_radius = 26.0/PTM_RATIO;
        
        b2FixtureDef ballShapeDef;
        ballShapeDef.shape = &circle;
        ballShapeDef.density = 1.0f;
        ballShapeDef.friction = 0.f;
        ballShapeDef.restitution = 1.0f;
        _ballFixture=_body->CreateFixture(&ballShapeDef);
        
       
        //this determines the speed of the ball projectile
        b2Vec2 force = b2Vec2(1,1);
        _body->ApplyLinearImpulse(force, ballBodyDef.position);*/



//will be removing this later right? --edit: i removed it :P
        // Create the ball and add it to the layer
//        ball = [CCSprite spriteWithFile:@"projectile.png" rect:CGRectMake(0, 0, 52, 52)];
//        ball.position = ccp(0, 0);
//        [balls addObject:ball];


~~~~~~~~~~~~~~~~~~
//Create a hungry eevee and add it to layer
        /*CCSprite *hungryEevee = [CCSprite spriteWithFile: @"hungryEevee.png"];
        hungryEevee.position = ccp(winSize.width - 10, winSize.height/2);
        [self addChild:hungryEevee z:0 tag:2];
        
        //Create the hungry eevee mouth -- useful to detect collision
        
        CCSprite *hungryEeveeMouth = [CCSprite spriteWithFile: @"hungryEeveeMouth.png"];
        hungryEeveeMouth.position = ccp(450, 148);
        [self addChild:hungryEeveeMouth z:-1 tag:1];*/




//        // Create paddle body
//        b2BodyDef paddleBodyDef;
//        paddleBodyDef.type = b2_dynamicBody;
//        //paddleBodyDef.position.Set(winSize.width/2/PTM_RATIO, winSize.height/2/PTM_RATIO);
//        paddleBodyDef.position.Set(10/PTM_RATIO, winSize.height/2/PTM_RATIO);
//        paddleBodyDef.userData = (__bridge void*)paddle;
//        _paddleBody = world->CreateBody(&paddleBodyDef);
//
        
        // Create paddle shape
//        b2PolygonShape paddleShape;
//        paddleShape.SetAsBox(_player.contentSize.width/PTM_RATIO/2,
//                             _player.contentSize.height/PTM_RATIO/2);
//        
//        // Create shape definition and add to body
//        b2FixtureDef paddleShapeDef;
//        paddleShapeDef.shape = &paddleShape;
//        paddleShapeDef.density = 10.0f;
//        paddleShapeDef.friction = 0.4f;
//        paddleShapeDef.restitution = 0.1f;
//        _paddleFixture = _paddleBody->CreateFixture(&paddleShapeDef);


        //Make paddle horizontal plane


//        b2PrismaticJointDef jointDef;
//        b2Vec2 worldAxis(0.0f, 1.0f);
//        jointDef.collideConnected = true;
//        jointDef.Initialize(_paddleBody, _groundBody, _paddleBody->GetWorldCenter(), worldAxis);
//
//        world->CreateJoint(&jointDef);





//- ( void ) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    UITouch *touch = [touches anyObject];
//    locationTouchBegan = [touch locationInView: [touch view]];
//    //location is The Point Where The User Touched
//    locationTouchBegan = [[CCDirector sharedDirector] convertToGL:locationTouchBegan];
//    //Detect the Touch On Ball
//    if(CGRectContainsPoint([ball boundingBox], locationTouchBegan))
//    {
//        isBallTouched=YES;
//    }
//
//}
//- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event
//{
//    // Choose one of the touches to work with
//    UITouch *touch = [touches anyObject];
//    CGPoint location = [touch locationInView:[touch view]];
//    location = [[CCDirector sharedDirector] convertToGL:location];
//
//    //  Determine offset of location to projectile
//    int offX = location.x - ball.position.x;
//    int offY = location.y - ball.position.y;
//
//    // Bail out if we are shooting down or backwards
//    if (offX <= 0)
//        return;
//
//    // Determine where we wish to shoot the projectile to
//    int realX = winSize.width + (ball.contentSize.height/2);
//    float ratio = (float) offY / (float) offX;
//    int realY = (realX * ratio) + ball.position.y;
//    CGPoint realDest = ccp(realX, realY);
//
//    if(realX>=320)
//        realX = 320;
//    if(realY>=480)
//        realY = 480;
//
//
//    //int good = goodBarrel.position.x;
//    //int bad = badBarrel.position.x;
//
//    int destY = realDest.x;
//
//    realDest.x = destY+10;
//
//    // Determine the length of how far we're shooting
//    int offRealX = realX - ball.position.x;
//    int offRealY = realY - ball.position.y;
//    float length = sqrtf((offRealX*offRealX)+(offRealY*offRealY));
//    float velocity = 480/1; // 480pixels/1sec
//    float realMoveDuration = length/velocity;
//
//    // Move projectile to actual endpoint
//    [ball runAction:[CCSequence actions:
//                     [CCMoveTo actionWithDuration:realMoveDuration position:realDest],
//                     [CCCallFuncN actionWithTarget:self selector:@selector(spriteMoveFinished:)],
//                     nil]];
//    [ball runAction:[CCScaleTo actionWithDuration:realMoveDuration scale:0.4f]];
//	if ((self = [super init]))
//	{
//		CCLOG(@"%@ init", NSStringFromClass([self class]));
//
//		glClearColor(0.1f, 0.0f, 0.2f, 1.0f);
//
//		// Construct a world object, which will hold and simulate the rigid bodies.
//		b2Vec2 gravity = b2Vec2(0.0f, -10.0f);
//		world = new b2World(gravity);
//		world->SetAllowSleeping(YES);
//		//world->SetContinuousPhysics(YES);
//
//		// uncomment this line to draw debug info
//		[self enableBox2dDebugDrawing];
//
//		contactListener = new ContactListener();
//		world->SetContactListener(contactListener);
//
//		// for the screenBorder body we'll need these values
//		CGSize screenSize = [CCDirector sharedDirector].winSize;
//		float widthInMeters = screenSize.width / PTM_RATIO;
//		float heightInMeters = screenSize.height / PTM_RATIO;
//		b2Vec2 lowerLeftCorner = b2Vec2(0, 0);
//		b2Vec2 lowerRightCorner = b2Vec2(widthInMeters, 0);
//		b2Vec2 upperLeftCorner = b2Vec2(0, heightInMeters);
//		b2Vec2 upperRightCorner = b2Vec2(widthInMeters, heightInMeters);
//
//		// Define the static container body, which will provide the collisions at screen borders.
//		b2BodyDef screenBorderDef;
//		screenBorderDef.position.Set(0, 0);
//		b2Body* screenBorderBody = world->CreateBody(&screenBorderDef);
//		b2EdgeShape screenBorderShape;
//
//		// Create fixtures for the four borders (the border shape is re-used)
//		screenBorderShape.Set(lowerLeftCorner, lowerRightCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(lowerRightCorner, upperRightCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(upperRightCorner, upperLeftCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//		screenBorderShape.Set(upperLeftCorner, lowerLeftCorner);
//		screenBorderBody->CreateFixture(&screenBorderShape, 0);
//
//		NSString* message = @"Tap Screen For More Awesome!";
//		if ([CCDirector sharedDirector].currentPlatformIsMac)
//		{
//			message = @"Click Window For More Awesome!";
//		}
//
//		CCLabelTTF* label = [CCLabelTTF labelWithString:message fontName:@"Marker Felt" fontSize:32];
//		[self addChild:label];
//		[label setColor:ccc3(222, 222, 255)];
//		label.position = CGPointMake(screenSize.width / 2, screenSize.height - 50);
//
//		// Use the orthogonal tileset for the little boxes
//		CCSpriteBatchNode* batch = [CCSpriteBatchNode batchNodeWithFile:@"dg_grounds32.png" capacity:TILESET_ROWS * TILESET_COLUMNS];
//		[self addChild:batch z:0 tag:kTagBatchNode];
//
//		// Add a few objects initially
//		for (int i = 0; i < 9; i++)
//		{
//			[self addNewSpriteAt:CGPointMake(screenSize.width / 2, screenSize.height / 2)];
//		}
//
//		[self addSomeJoinedBodies:CGPointMake(screenSize.width / 4, screenSize.height - 50)];
//
//		[self scheduleUpdate];
//
//		[KKInput sharedInput].accelerometerActive = YES;
//	}
//
//	return self;
